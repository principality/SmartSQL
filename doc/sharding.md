# 分片

对一个原生不支持分布式的存储层而言，分片的实现是分布式的关键模块。
可以把多台MySQL看成是支持下推的存储节点集群。

## 思路

分片的方法有多种，需要抽象其实现流程

- 获取分片的方法，初始化分片的处理器
- 查询/更新/插入/删除，根据分片方法分配到不同的片上
  - 根据不同的分片方法调用分片的实现方法，计划支持的分片策略：
    1. 按表名指定目标数据库；
    2. 按主键Hash分片；
    3. 按主键范围分片；
  - 通过建立业务字段与主键的对应关系索引(映射关系)，可实现根据业务字段定位分片功能：
    1. treemap
    2. bitmap
    3. inverted index
- 合并从一个或多个分片获得最终结果

## 组件

### index

index是核心功能，假如对数据进行查询，且查询条件不包含分片主键时，
不带index会导致数据查询被迫分派到所有的后端上，引起数据查询的多余执行
- debezium用于抽取mysql数据记录
- treemap: akka-distributed-data, mapdb, hazelcast, apache geode, apache ignite

### util

对分片方法实现的支撑算法

- range: 指定分片算法
  - auto-increase-id / range，分区算法
- keygen: 键分片算法
  - mysql自增id，一致性hash
  - snowflake按主键中的服务器编号获得目标服务器
  - 全局服务唯一id可以按HASH进行分配

### merge

完成分片的计算后，需要把结果进行合并

### meta

记录分片的表信息
- 分片的列表，与服务器对应
- 分片的方法，以及相应的参数

先用model.json文件进行配置，计划将来该部分实现放到MetaRepository中

## 二次分片（扩容）

### name
根据表名指定目标的服务器，常见的分库策略，从业务维度进行库切分，适用于表多业务多但单表的数据量有限的情况

### range
range采用volume式增长进行管理，range是假设读多写少且整体数据读压力均匀情况下的分片策略

### hash
hash是针对单表数据很多（如超过一千万）的压力情况提出的解决方案

hash某个片下面的数据量会持续增加，通常采取一分二的策略进行扩容，
vitess的做法是先把数据一分二拷贝到两台服务器上，
然后锁定原数据（只读），把流量切换到新的两台服务器上，整个过程通过一系列的指令进行，
需要服务器实现动态的meta管理、数据可控同步拷贝等基础功能

另外一种做法是一致性hash虚拟节点：按业务的增长情况预设一定的虚拟服务器数量，
如预计业务会从10台设备持续增长到100台机器，则在原来10台设备上一开始就按100台进行分片，
并把100个节点和10台设备做映射，随着服务器的压力增加，把原来1台真实设备承担的压力逐步分摊到多台上

举例：设备A上，配置多个数据库
- jdbc:mysql://nodeA:33061/node1/table
- jdbc:mysql://nodeA:33061/node2/table

随着压力的增加，从单个机器变化为多个机器
- jdbc:mysql://nodeA:33061/node1/table
- jdbc:mysql://nodeB:33061/node1/table

### 常见的业务数据读写维度

根据业务情况选择分布方案

- 读写比例
- 读写分布 
